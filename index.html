<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ready2Study - Transform PDFs into Study Material</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <header>
        <div class="container nav-content">
            <a href="index.html" class="logo">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                </svg>
                Ready<span>2Study</span>
            </a>
            <nav>
                <!-- <a href="#" class="btn btn-secondary">Sign In</a> -->
            </nav>
        </div>
    </header>

    <main class="hero">
        <div class="container">
            <div class="hero-content">
                <h1 id="greeting">Turn Your Notes into<br>Exam-Ready Questions</h1>
                <p>Upload your study material (PDF) and let our AI generate 1-mark, 2-mark, 3-mark, and 10-mark
                    questions instantly.</p>

                <div class="upload-card">
                    <div class="drop-zone" id="dropZone">
                        <svg class="icon-upload" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <h3>Drag & Drop your PDF here</h3>
                        <p style="font-size: 0.875rem; color: var(--text-muted);">or click to browse files</p>
                        <input type="file" id="fileInput" accept=".pdf" style="display: none;">
                        <div class="file-info" id="fileInfo"></div>
                    </div>
                    <button class="btn btn-primary" id="generateBtn" style="width: 100%; margin-top: 1.5rem;" disabled>
                        Generate Questions
                    </button>
                </div>
            </div>
        </div>
    </main>

    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <h3 id="loaderTitle">Reading PDF Document...</h3>
        <p id="loaderMessage" style="color: var(--text-muted);">Extracting content and analyzing structure</p>
        <div id="loaderProgress" style="margin-top: 2rem; width: 300px; max-width: 90%;">
            <div style="background: rgba(255,255,255,0.3); height: 8px; border-radius: 4px; overflow: hidden;">
                <div id="progressBar" style="background: var(--gradient-primary); height: 100%; width: 0%; transition: width 0.3s; border-radius: 4px;"></div>
            </div>
            <div id="progressText" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">0%</div>
        </div>
    </div>

    <!-- PDF.js library for reading PDF content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="js/api-service.js"></script>
    <script src="js/mockData.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const generateBtn = document.getElementById('generateBtn');
            const loader = document.getElementById('loader');

            // Check if user is authenticated via localStorage
            console.log('=== INDEX.HTML PAGE LOAD ===');
            console.log('Timestamp:', new Date().toISOString());
            
            let userData = null;
            console.log('â†’ Checking localStorage for user data...');
            const storedUser = localStorage.getItem('ready2study_user');
            
            if (!storedUser) {
                // No user data found, redirect to registration
                console.log('âœ— No user data found in localStorage');
                console.log('â†’ Redirecting to student-info.html...');
                window.location.href = 'student-info.html';
                return;
            }
            
            console.log('âœ“ User data found in localStorage');
            try {
                userData = JSON.parse(storedUser);
                console.log('âœ“ User data parsed successfully:', userData);
                console.log('=== USER AUTHENTICATED - CONTINUING TO UPLOAD PAGE ===');
            } catch (error) {
                // Invalid user data, redirect to registration
                console.error('âœ— Invalid user data in localStorage:', error);
                console.log('â†’ Redirecting to student-info.html...');
                window.location.href = 'student-info.html';
                return;
            }

            // Click on drop zone to trigger file input
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // Drag and drop handlers
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'application/pdf') {
                    handleFile(files[0]);
                } else {
                    alert('Please upload a PDF file.');
                }
            });

            // File input change handler
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    if (file.type === 'application/pdf') {
                        handleFile(file);
                    } else {
                        alert('Please upload a PDF file.');
                        fileInput.value = '';
                    }
                }
            });

            function handleFile(file) {
                // Validate file type
                if (file.type !== 'application/pdf') {
                    alert('Please upload a PDF file only.');
                    fileInput.value = '';
                    return;
                }

                // Display file information
                const fileSize = (file.size / 1024 / 1024).toFixed(2); // Convert to MB
                fileInfo.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-top: 1rem; padding: 1rem; background: #f0fdfa; border-radius: 0.5rem; border: 1px solid var(--border);">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--primary);">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                        </svg>
                        <div style="flex: 1;">
                            <strong style="color: var(--primary); display: block; margin-bottom: 0.25rem;">${file.name}</strong>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">${fileSize} MB</div>
                        </div>
                        <button onclick="removeFile()" style="background: #fee2e2; color: #991b1b; border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='#fecaca'" onmouseout="this.style.background='#fee2e2'">Remove</button>
                    </div>
                `;
                fileInfo.style.display = 'block';
                generateBtn.disabled = false;

                // Store file information in localStorage
                localStorage.setItem('ready2study_pdf', JSON.stringify({
                    name: file.name,
                    size: file.size,
                    uploaded: true,
                    uploadDate: new Date().toISOString()
                }));

                // Store the file object for later processing
                window.currentPDFFile = file;
                
                // Read file as ArrayBuffer for PDF.js
                const reader = new FileReader();
                reader.onload = function(e) {
                    // Store file data for PDF processing
                    window.currentPDFArrayBuffer = e.target.result;
                    console.log('PDF file loaded successfully:', file.name);
                };
                reader.onerror = function() {
                    alert('Error reading file. Please try again.');
                    removeFile();
                };
                reader.readAsArrayBuffer(file);
            }

            // Remove file function
            window.removeFile = function() {
                if (confirm('Are you sure you want to remove this file?')) {
                    fileInput.value = '';
                    fileInfo.style.display = 'none';
                    fileInfo.innerHTML = '';
                    generateBtn.disabled = true;
                    localStorage.removeItem('ready2study_pdf');
                }
            };

            // Function to extract text from PDF - reads ALL pages completely
            async function extractTextFromPDF(arrayBuffer) {
                try {
                    // Set up PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // Load the PDF document
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    let fullText = '';
                    const totalPages = pdf.numPages;
                    
                    console.log(`ðŸ“„ Reading PDF with ${totalPages} pages...`);
                    console.log(`ðŸ“– Starting to read ALL pages completely...`);
                    
                    // Extract text from EACH AND EVERY page completely
                    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            
                            // Better extraction that preserves mathematical formulas and equations
                            let pageText = '';
                            for (let item of textContent.items) {
                                // Preserve spacing and special characters for math
                                const text = item.str || '';
                                // Check if it's a mathematical expression (contains numbers, operators, etc.)
                                if (text.match(/[0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€]/) || text.trim().length > 0) {
                                    pageText += text + (item.hasEOL ? '\n' : ' ');
                                } else {
                                    pageText += text + ' ';
                                }
                            }
                            
                            // Add page separator
                            fullText += `\n--- Page ${pageNum} of ${totalPages} ---\n\n`;
                            fullText += pageText.trim();
                            fullText += '\n\n';
                            
                            console.log(`âœ… Page ${pageNum}/${totalPages} extracted successfully (${pageText.length} characters)`);
                        } catch (pageError) {
                            console.error(`âŒ Error reading page ${pageNum}:`, pageError);
                            // Continue with next page even if one fails
                            fullText += `\n--- Page ${pageNum} (Error reading) ---\n\n`;
                        }
                    }
                    
                    console.log(`âœ… PDF extraction complete!`);
                    console.log(`ðŸ“Š Total text length: ${fullText.length} characters`);
                    console.log(`ðŸ“„ Total pages read: ${totalPages}`);
                    return fullText.trim();
                } catch (error) {
                    console.error('Error extracting text from PDF:', error);
                    throw error;
                }
            }

            // Function to generate questions from PDF content - properly separates questions and answers
            function generateQuestionsFromPDF(pdfText) {
                console.log('Generating questions from PDF content...');
                console.log('PDF text length:', pdfText.length);
                console.log('First 500 chars of PDF:', pdfText.substring(0, 500));
                
                // Helper function to extract key concepts and topics from text
                function extractKeyConcepts(text) {
                    // Remove page markers and clean text
                    let cleanText = text.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                    
                    // Extract sentences
                    const sentences = cleanText.split(/[.!?]+/).filter(s => s.trim().length > 15);
                    
                    // Extract important nouns and concepts (words that are capitalized or appear multiple times)
                    const words = cleanText.toLowerCase().split(/\s+/);
                    const wordFreq = {};
                    words.forEach(w => {
                        const clean = w.replace(/[^a-z0-9]/g, '');
                        if (clean.length > 4) {
                            wordFreq[clean] = (wordFreq[clean] || 0) + 1;
                        }
                    });
                    
                    // Get most frequent meaningful words
                    const importantWords = Object.entries(wordFreq)
                        .filter(([w, count]) => count > 1 && w.length > 4)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                        .map(([w]) => w);
                    
                    // Extract capitalized terms (likely concepts)
                    const capitalizedTerms = cleanText.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
                    const uniqueCapTerms = [...new Set(capitalizedTerms)].slice(0, 5);
                    
                    return {
                        sentences: sentences,
                        importantWords: importantWords,
                        capitalizedTerms: uniqueCapTerms,
                        fullText: cleanText
                    };
                }
                
                // Helper function to identify what a passage is about and create a question
                function createQuestionFromContent(passage, marks) {
                    if (!passage || passage.trim().length < 30) return null;
                    
                    const concepts = extractKeyConcepts(passage);
                    const sentences = concepts.sentences;
                    
                    if (sentences.length === 0) return null;
                    
                    // Clean the passage to use as answer
                    let answerText = passage.trim();
                    // Remove page markers from answer
                    answerText = answerText.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                    // Limit answer length based on marks
                    const maxAnswerLength = marks === 1 ? 200 : marks === 2 ? 300 : marks === 3 ? 500 : 1000;
                    answerText = answerText.substring(0, Math.min(maxAnswerLength, answerText.length)).trim();
                    
                    if (answerText.length < 30) return null;
                    
                    // Identify the main topic/concept from the passage
                    let mainTopic = '';
                    
                    // Try to find the main subject/topic
                    if (concepts.capitalizedTerms.length > 0) {
                        mainTopic = concepts.capitalizedTerms[0];
                    } else if (concepts.importantWords.length > 0) {
                        // Capitalize first letter of important word
                        mainTopic = concepts.importantWords[0].charAt(0).toUpperCase() + concepts.importantWords[0].slice(1);
                    } else {
                        // Extract first meaningful phrase from first sentence
                        const firstSentence = sentences[0].trim();
                        const words = firstSentence.split(/\s+/).filter(w => w.length > 3);
                        if (words.length > 0) {
                            mainTopic = words.slice(0, 3).join(' ');
                        } else {
                            mainTopic = firstSentence.substring(0, 50);
                        }
                    }
                    
                    // Check if it's mathematical content
                    const hasMath = /[0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€]/.test(passage);
                    
                    // Generate question based on marks
                    let questionText = '';
                    
                    if (hasMath) {
                        // Mathematical questions
                        const mathExpr = passage.match(/([0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€\s]+)/)?.[0] || '';
                        if (marks === 1) {
                            questionText = `${mathExpr.substring(0, 80).trim()}`;
                        } else if (marks === 2) {
                            questionText = `${mathExpr.substring(0, 120).trim()}`;
                        } else {
                            questionText = `${mathExpr.substring(0, 150).trim()}`;
                        }
                    } else {
                        // Text-based questions - create proper exam questions
                        if (marks === 1) {
                            // Simple definition/recall
                            questionText = `What is ${mainTopic}?`;
                        } else if (marks === 2) {
                            // Short explanation
                            questionText = `Explain ${mainTopic}.`;
                        } else if (marks === 3) {
                            // Detailed explanation
                            questionText = `Describe ${mainTopic} in detail.`;
                        } else {
                            // Comprehensive (10 marks)
                            questionText = `Write a comprehensive answer about ${mainTopic}.`;
                        }
                    }
                    
                    // CRITICAL: Ensure question and answer are completely different
                    // Question should ask ABOUT something, answer should explain it
                    const normalizedQuestion = questionText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
                    const normalizedAnswer = answerText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
                    
                    // Check if question and answer are too similar
                    if (normalizedQuestion === normalizedAnswer || 
                        normalizedAnswer.includes(normalizedQuestion) && normalizedAnswer.length < normalizedQuestion.length * 2 ||
                        normalizedQuestion.length >= normalizedAnswer.length) {
                        // If too similar, try to extract a better topic
                        const betterTopic = sentences[0].split(/\s+/).slice(0, 4).join(' ');
                        if (marks === 1) {
                            questionText = `What is ${betterTopic}?`;
                        } else if (marks === 2) {
                            questionText = `Explain ${betterTopic}.`;
                        } else if (marks === 3) {
                            questionText = `Describe ${betterTopic} in detail.`;
                        } else {
                            questionText = `Write a comprehensive answer about ${betterTopic}.`;
                        }
                    }
                    
                    // Final validation
                    if (questionText.trim().length < 10 || answerText.trim().length < 30) {
                        return null;
                    }
                    
                    // Ensure answer is significantly longer than question
                    if (answerText.length <= questionText.length * 1.5) {
                        return null; // Answer too short, skip this
                    }
                    
                    return {
                        question: questionText.trim(),
                        answer: answerText.trim()
                    };
                }
                
                // Split text into meaningful sections (paragraphs, sections, etc.)
                // First, remove page markers
                let cleanText = pdfText.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                
                // Split into paragraphs (double newlines or long single lines)
                let paragraphs = cleanText.split(/\n\s*\n/).filter(p => p.trim().length > 30);
                
                // If not enough paragraphs, try splitting by single newlines for longer sections
                if (paragraphs.length < 10) {
                    const lines = cleanText.split('\n').filter(l => l.trim().length > 50);
                    // Group consecutive lines into paragraphs
                    let currentPara = '';
                    lines.forEach(line => {
                        if (line.trim().length > 0) {
                            currentPara += line.trim() + ' ';
                            if (currentPara.length > 200) {
                                paragraphs.push(currentPara.trim());
                                currentPara = '';
                            }
                        } else if (currentPara.length > 30) {
                            paragraphs.push(currentPara.trim());
                            currentPara = '';
                        }
                    });
                    if (currentPara.length > 30) {
                        paragraphs.push(currentPara.trim());
                    }
                }
                
                // Remove duplicates and very short paragraphs
                paragraphs = [...new Set(paragraphs)].filter(p => p.trim().length > 30);
                
                console.log(`Found ${paragraphs.length} paragraphs/sections in PDF`);
                
                const questions = [];
                let questionId = 1;
                const examDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                
                // Generate MORE than 20 questions - ensure good distribution
                // Target: At least 20-25 questions total (minimum 20, aim for 25+)
                const targetCounts = {
                    1: Math.max(8, Math.min(12, Math.floor(paragraphs.length / 1.5) || 8)),  // Minimum 8, up to 12 questions
                    2: Math.max(8, Math.min(12, Math.floor(paragraphs.length / 1.5) || 8)),  // Minimum 8, up to 12 questions
                    3: Math.max(4, Math.min(8, Math.floor(paragraphs.length / 1.2) || 4)),   // Minimum 4, up to 8 questions
                    10: Math.max(2, Math.min(4, Math.floor(paragraphs.length / 1.0) || 2))   // Minimum 2, up to 4 questions
                };
                
                // Ensure minimum total of 20 questions
                const totalTarget = targetCounts[1] + targetCounts[2] + targetCounts[3] + targetCounts[10];
                if (totalTarget < 20) {
                    // Adjust to ensure at least 20 questions
                    const shortfall = 20 - totalTarget;
                    // Distribute shortfall across categories
                    targetCounts[1] += Math.ceil(shortfall * 0.4);
                    targetCounts[2] += Math.ceil(shortfall * 0.4);
                    targetCounts[3] += Math.ceil(shortfall * 0.15);
                    targetCounts[10] += Math.ceil(shortfall * 0.05);
                }
                
                console.log(`ðŸ“Š Target question counts: 1-mark=${targetCounts[1]}, 2-mark=${targetCounts[2]}, 3-mark=${targetCounts[3]}, 10-mark=${targetCounts[10]} (Total: ${targetCounts[1] + targetCounts[2] + targetCounts[3] + targetCounts[10]})`);
                
                // Track paragraph usage count (allow reuse for long paragraphs)
                const paragraphUsage = new Map();
                
                // Generate questions for each mark category
                [1, 2, 3, 10].forEach(marks => {
                    let generated = 0;
                    const targetCount = targetCounts[marks];
                    
                    console.log(`Generating ${targetCount} questions for ${marks}-mark category...`);
                    
                    // Try each paragraph until we have enough questions
                    // Allow reusing paragraphs if they're long enough - be more aggressive
                    for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                    const para = paragraphs[i].trim();
                        const minLength = marks === 1 ? 40 : marks === 2 ? 80 : marks === 3 ? 120 : 150; // Lowered minimums
                        
                        // Check usage - allow more reuse for longer paragraphs
                        const usageCount = paragraphUsage.get(i) || 0;
                        // More aggressive reuse: allow 3-4 uses for very long paragraphs
                        const maxReuse = para.length > 800 ? 4 : para.length > 500 ? 3 : para.length > 300 ? 2 : para.length > 150 ? 1 : 0;
                        
                        if (para.length >= minLength && usageCount < maxReuse) {
                            const qa = createQuestionFromContent(para, marks);
                            
                            if (qa && 
                                qa.question && 
                                qa.answer &&
                                qa.question.trim() !== qa.answer.trim() &&
                                qa.question.length > 8 && // Lowered minimum
                                qa.answer.length > qa.question.length * 1.2 && // Less strict ratio
                                !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                            
                            questions.push({
                                id: questionId++,
                                    question: qa.question,
                                    answer: qa.answer,
                                    marks: marks,
                                    examDate: examDate
                                });
                                
                                paragraphUsage.set(i, usageCount + 1);
                                generated++;
                                console.log(`âœ… Generated ${marks}-mark question ${generated}/${targetCount}: "${qa.question.substring(0, 50)}..."`);
                            }
                        }
                    }
                    
                    // If still not enough, try cycling through paragraphs multiple times
                    if (generated < targetCount) {
                        console.log(`âš ï¸ Only ${generated}/${targetCount} generated. Cycling through paragraphs again...`);
                        let attempts = 0;
                        const maxAttempts = paragraphs.length * 2; // Try twice through all paragraphs
                        
                        while (generated < targetCount && attempts < maxAttempts) {
                            for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                                const para = paragraphs[i].trim();
                                const minLength = marks === 1 ? 30 : marks === 2 ? 60 : marks === 3 ? 100 : 120; // Even lower
                                
                                const usageCount = paragraphUsage.get(i) || 0;
                                const maxReuse = para.length > 400 ? 5 : para.length > 200 ? 3 : 2; // More aggressive
                                
                                if (para.length >= minLength && usageCount < maxReuse) {
                                    const qa = createQuestionFromContent(para, marks);
                                    
                                    if (qa && 
                                        qa.question && 
                                        qa.answer &&
                                        qa.question.trim() !== qa.answer.trim() &&
                                        qa.question.length > 8 &&
                                        qa.answer.length > qa.question.length * 1.1 &&
                                        !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                                        
                        questions.push({
                            id: questionId++,
                                            question: qa.question,
                                            answer: qa.answer,
                                            marks: marks,
                                            examDate: examDate
                                        });
                                        
                                        paragraphUsage.set(i, usageCount + 1);
                                        generated++;
                                        attempts++;
                                    }
                                }
                                attempts++;
                            }
                        }
                    }
                    
                    // If still not enough, try splitting longer paragraphs into smaller chunks
                    if (generated < targetCount) {
                        console.log(`âš ï¸ Still need ${targetCount - generated} more ${marks}-mark questions. Splitting long paragraphs...`);
                        
                        // Try splitting longer paragraphs into smaller chunks
                        for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                    const para = paragraphs[i].trim();
                            
                            // If paragraph is long enough, split it and generate multiple questions
                            if (para.length > 300) {
                                // Split by sentences
                                const sentences = para.split(/[.!?]+/).filter(s => s.trim().length > 30);
                                
                                // Create overlapping chunks to generate more questions
                                for (let startIdx = 0; startIdx < sentences.length - 1 && generated < targetCount; startIdx++) {
                                    // Take 2-4 sentences per chunk
                                    const chunkSize = marks === 1 ? 2 : marks === 2 ? 3 : marks === 3 ? 4 : 5;
                                    const chunk = sentences.slice(startIdx, startIdx + chunkSize).join('. ').trim();
                                    
                                    if (chunk.length >= (marks === 1 ? 40 : marks === 2 ? 80 : marks === 3 ? 120 : 150)) {
                                        const qa = createQuestionFromContent(chunk, marks);
                                        
                                        if (qa && 
                                            qa.question && 
                                            qa.answer &&
                                            qa.question.trim() !== qa.answer.trim() &&
                                            qa.question.length > 8 &&
                                            qa.answer.length > qa.question.length * 1.1 &&
                                            !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                            
                            questions.push({
                                id: questionId++,
                                                question: qa.question,
                                                answer: qa.answer,
                                                marks: marks,
                                                examDate: examDate
                                            });
                                            
                                            generated++;
                                            console.log(`âœ… Generated additional ${marks}-mark question from split: "${qa.question.substring(0, 50)}..."`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    console.log(`ðŸ“Š Final count for ${marks}-mark: ${generated}/${targetCount} questions`);
                });
                
                // Final validation and cleanup - keep all valid questions (be less strict to keep more)
                const validQuestions = [];
                const seenQuestions = new Set();
                
                questions.forEach(q => {
                    const qNorm = q.question.toLowerCase().trim();
                    const aNorm = q.answer.toLowerCase().trim();
                    
                    // Less strict validation - ensure questions and answers are different but allow more through
                    if (q.question && 
                        q.answer &&
                        q.question.trim().length > 8 && // Lowered from 10
                        q.answer.trim().length > 25 && // Lowered from 30
                        qNorm !== aNorm &&
                        q.answer.length > q.question.length * 1.1 && // Less strict ratio (was 1.2)
                        !seenQuestions.has(qNorm)) {
                        
                        validQuestions.push(q);
                        seenQuestions.add(qNorm);
                    }
                });
                
                console.log(`ðŸ“‹ After validation: ${validQuestions.length} valid questions (from ${questions.length} generated)`);
                
                const countsByMark = {
                    1: validQuestions.filter(q => q.marks === 1).length,
                    2: validQuestions.filter(q => q.marks === 2).length,
                    3: validQuestions.filter(q => q.marks === 3).length,
                    10: validQuestions.filter(q => q.marks === 10).length
                };
                
                console.log(`âœ… Generated ${validQuestions.length} valid questions total:`);
                console.log(`   - ${countsByMark[1]} x 1-mark questions`);
                console.log(`   - ${countsByMark[2]} x 2-mark questions`);
                console.log(`   - ${countsByMark[3]} x 3-mark questions`);
                console.log(`   - ${countsByMark[10]} x 10-mark questions`);
                
                // If we have less than 20 questions, try to generate more from remaining content
                if (validQuestions.length < 20) {
                    console.log(`âš ï¸ Only ${validQuestions.length} questions generated. Target is 20+. Trying to generate more...`);
                    
                    // Try to generate more questions from unused or partially used paragraphs
                    const remainingParagraphs = paragraphs.filter((p, idx) => {
                        const usage = paragraphUsage.get(idx) || 0;
                        return usage === 0 || (p.length > 400 && usage < 2);
                    });
                    
                    // Generate additional questions from remaining content
                    [1, 2, 3, 10].forEach(marks => {
                        const currentCount = countsByMark[marks];
                        const targetCount = targetCounts[marks];
                        
                        if (currentCount < targetCount) {
                            const needed = targetCount - currentCount;
                            let generated = 0;
                            
                            for (let para of remainingParagraphs) {
                                if (generated >= needed) break;
                                
                                const qa = createQuestionFromContent(para, marks);
                                if (qa && 
                                    qa.question && 
                                    qa.answer &&
                                    qa.question.trim() !== qa.answer.trim() &&
                                    !validQuestions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                                    
                                    validQuestions.push({
                                id: questionId++,
                                        question: qa.question,
                                        answer: qa.answer,
                                        marks: marks,
                                        examDate: examDate
                                    });
                                    generated++;
                                }
                            }
                        }
                    });
                    
                    console.log(`âœ… After additional generation: ${validQuestions.length} total questions`);
                }
                
                // Final check - if still not enough, add from mock data (but only as last resort)
                if (validQuestions.length < 4) {
                    console.warn('âš ï¸ Not enough questions generated, adding mock questions as fallback');
                    const mockQuestionsToAdd = mockQuestions.slice(0, Math.min(4 - validQuestions.length, 4));
                    mockQuestionsToAdd.forEach(q => {
                        if (q.question && q.answer && q.question !== q.answer) {
                            validQuestions.push({
                            ...q,
                                id: questionId++,
                                examDate: examDate
                            });
                        }
                    });
                }
                
                // Sort questions by marks for better organization
                validQuestions.sort((a, b) => {
                    if (a.marks !== b.marks) return a.marks - b.marks;
                    return a.id - b.id;
                });
                
                console.log(`ðŸŽ‰ Final result: ${validQuestions.length} questions ready for use!`);
                
                return validQuestions;
            }

            // Generate questions button handler
            generateBtn.addEventListener('click', async () => {
                const pdfData = localStorage.getItem('ready2study_pdf');
                if (!pdfData) {
                    alert('Please upload a PDF file first.');
                    return;
                }

                if (!window.currentPDFArrayBuffer) {
                    alert('PDF file is still loading. Please wait a moment and try again.');
                    return;
                }

                // Disable button during processing
                generateBtn.disabled = true;
                generateBtn.textContent = 'Processing...';
                loader.style.display = 'flex';
                
                const loaderTitle = document.getElementById('loaderTitle');
                const loaderMessage = document.getElementById('loaderMessage');
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                
                try {
                    // Step 1: Reading PDF - ALL PAGES
                    loaderTitle.textContent = 'Reading PDF Document...';
                    loaderMessage.textContent = 'Reading ALL pages completely and extracting full content...';
                    progressBar.style.width = '20%';
                    progressText.textContent = '20% - Reading all PDF pages...';
                    
                    // Extract text from PDF - this now reads ALL pages completely
                    const pdfText = await extractTextFromPDF(window.currentPDFArrayBuffer);
                    
                    // Update progress after reading all pages
                    progressBar.style.width = '30%';
                    progressText.textContent = `30% - All pages read successfully (${pdfText.length.toLocaleString()} characters)`;
                    
                    console.log('ðŸ“„ PDF Text Extracted from all pages:', pdfText.substring(0, 500) + '...');
                    console.log('ðŸ“Š Total PDF content length:', pdfText.length.toLocaleString(), 'characters');
                    
                    // Step 2: Analyzing Content
                    loaderTitle.textContent = 'Analyzing Content...';
                    loaderMessage.textContent = 'Identifying key concepts, topics, and extracting meaningful sections...';
                    progressBar.style.width = '40%';
                    progressText.textContent = '40% - Analyzing content structure...';
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Step 3: Generating Questions (20+ questions)
                    loaderTitle.textContent = 'Generating Questions...';
                    loaderMessage.textContent = 'Creating 20+ questions organized by marks (1, 2, 3, 10 marks) from all PDF content...';
                    progressBar.style.width = '60%';
                    progressText.textContent = '60% - Generating questions from PDF content...';
                    
                    const pdfQuestions = generateQuestionsFromPDF(pdfText);
                    
                    // Update progress
                    progressBar.style.width = '80%';
                    progressText.textContent = `80% - Generated ${pdfQuestions.length} questions successfully`;
                    
                    // Step 4: Organizing by Marks
                    loaderTitle.textContent = 'Organizing by Marks...';
                    loaderMessage.textContent = 'Categorizing questions into 1-mark, 2-mark, 3-mark, and 10-mark categories';
                    progressBar.style.width = '80%';
                    progressText.textContent = '80% - Organizing by marks...';
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Organize questions by marks for display
                    const questionsByMarks = {
                        1: pdfQuestions.filter(q => q.marks === 1),
                        2: pdfQuestions.filter(q => q.marks === 2),
                        3: pdfQuestions.filter(q => q.marks === 3),
                        10: pdfQuestions.filter(q => q.marks === 10)
                    };
                    
                    console.log('PDF Fully Processed - Questions organized by marks:', {
                        '1 Mark': questionsByMarks[1].length,
                        '2 Marks': questionsByMarks[2].length,
                        '3 Marks': questionsByMarks[3].length,
                        '10 Marks': questionsByMarks[10].length,
                        'Total': pdfQuestions.length,
                        'PDF Content Length': pdfText.length
                    });
                    
                    // Step 5: Uploading to Backend
                    loaderTitle.textContent = 'Uploading to Server...';
                    loaderMessage.textContent = 'Saving PDF and questions to database';
                    progressBar.style.width = '90%';
                    progressText.textContent = '90% - Uploading to server...';
                    
                    // Upload PDF file to backend
                    const pdfResponse = await PDFAPI.upload(window.currentPDFFile, pdfText);
                    const pdfId = pdfResponse.pdf.id;
                    
                    // Prepare questions for API (remove id, add exam_date)
                    const questionsForAPI = pdfQuestions.map(q => ({
                        question_text: q.question,
                        answer_text: q.answer,
                        marks: q.marks,
                        exam_date: q.examDate || null,
                    }));
                    
                    // Save questions to backend
                    await QuestionAPI.createBulk(pdfId, questionsForAPI);
                    
                    // Step 6: Finalizing
                    loaderTitle.textContent = 'Finalizing...';
                    loaderMessage.textContent = 'Preparing questions and answers for display';
                    progressBar.style.width = '100%';
                    progressText.textContent = '100% - Complete!';
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Store PDF ID and questions in localStorage for quick access
                    // Ensure PDF ID is stored as number for API calls
                    localStorage.setItem('ready2study_current_pdf_id', String(pdfId));
                    localStorage.setItem('ready2study_pdf_questions', JSON.stringify(pdfQuestions));
                    localStorage.setItem('ready2study_pdf_content', pdfText);
                    localStorage.setItem('ready2study_pdf_uploaded', 'true');
                    localStorage.setItem('ready2study_pdf_name', window.currentPDFFile.name);
                    
                    console.log('âœ“ PDF uploaded successfully!');
                    console.log('  PDF ID:', pdfId);
                    console.log('  Questions saved:', pdfQuestions.length);
                    console.log('  Redirecting to dashboard...');
                    
                    loader.style.display = 'none';
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Questions';
                    
                    // Small delay to ensure localStorage is saved before redirect
                    await new Promise(resolve => setTimeout(resolve, 100));
                    window.location.href = 'dashboard.html';
                    
                } catch (error) {
                    console.error('Error processing PDF:', error);
                    loader.style.display = 'none';
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Questions';
                    alert('Error processing PDF. Please try again or use a different PDF file. Error: ' + error.message);
                }
            });

            // Prevent default drag behaviors on the page
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
        });
    </script>
</body>
</html>