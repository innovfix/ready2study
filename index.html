<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ready2Study - Transform PDFs into Study Material</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <header>
        <div class="container nav-content">
            <a href="index.html" class="logo">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                </svg>
                Ready<span>2Study</span>
            </a>
            <nav>
                <!-- <a href="#" class="btn btn-secondary">Sign In</a> -->
            </nav>
        </div>
    </header>

    <main class="hero">
        <div class="container">
            <div class="hero-content">
                <h1 id="greeting">Turn Your Notes into<br>Exam-Ready Questions</h1>
                <p>Upload your study material (PDF) and let our AI generate 1-mark, 2-mark, 3-mark, and 10-mark
                    questions instantly.</p>

                <div class="upload-card">
                    <div class="drop-zone" id="dropZone">
                        <svg class="icon-upload" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="17 8 12 3 7 8"></polyline>
                            <line x1="12" y1="3" x2="12" y2="15"></line>
                        </svg>
                        <h3>Drag & Drop your PDF here</h3>
                        <p style="font-size: 0.875rem; color: var(--text-muted);">or click to browse files</p>
                        <input type="file" id="fileInput" accept=".pdf" multiple style="display: none;">
                        <div class="file-info" id="fileInfo"></div>
                    </div>
                    <button class="btn btn-primary" id="generateBtn" style="width: 100%; margin-top: 1.5rem;" disabled>
                        Generate Questions
                    </button>
                </div>
            </div>
        </div>
    </main>

    <div class="loader-overlay" id="loader">
        <div class="spinner"></div>
        <h3 id="loaderTitle">Reading PDF Document...</h3>
        <p id="loaderMessage" style="color: var(--text-muted);">Extracting content and analyzing structure</p>
        <div id="loaderProgress" style="margin-top: 2rem; width: 300px; max-width: 90%;">
            <div style="background: rgba(255,255,255,0.3); height: 8px; border-radius: 4px; overflow: hidden;">
                <div id="progressBar" style="background: var(--gradient-primary); height: 100%; width: 0%; transition: width 0.3s; border-radius: 4px;"></div>
            </div>
            <div id="progressText" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">0%</div>
        </div>
    </div>

    <!-- PDF.js library for reading PDF content -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="js/api-service.js"></script>
    <script src="js/mockData.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const generateBtn = document.getElementById('generateBtn');
            const loader = document.getElementById('loader');

            // Check if user is authenticated via localStorage
            console.log('=== INDEX.HTML PAGE LOAD ===');
            console.log('Timestamp:', new Date().toISOString());
            
            let userData = null;
            console.log('â†’ Checking localStorage for user data...');
            const storedUser = localStorage.getItem('ready2study_user');
            
            if (!storedUser) {
                // No user data found, redirect to registration
                console.log('âœ— No user data found in localStorage');
                console.log('â†’ Redirecting to student-info.html...');
                window.location.href = 'student-info.html';
                return;
            }
            
            console.log('âœ“ User data found in localStorage');
            try {
                userData = JSON.parse(storedUser);
                console.log('âœ“ User data parsed successfully:', userData);
                console.log('=== USER AUTHENTICATED - CONTINUING TO UPLOAD PAGE ===');
            } catch (error) {
                // Invalid user data, redirect to registration
                console.error('âœ— Invalid user data in localStorage:', error);
                console.log('â†’ Redirecting to student-info.html...');
                window.location.href = 'student-info.html';
                return;
            }

            // Click on drop zone to trigger file input
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            // Drag and drop handlers
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                const files = e.dataTransfer.files;
                addPdfFiles(files);
            });

            // File input change handler
            fileInput.addEventListener('change', (e) => {
                addPdfFiles(e.target.files);
            });

            // Multi-PDF selection support
            const selectedPDFs = [];
            window.selectedPDFs = selectedPDFs;

            function isPdfFile(file) {
                if (!file) return false;
                if (file.type === 'application/pdf') return true;
                return (file.name || '').toLowerCase().endsWith('.pdf');
            }

            function formatMB(bytes) {
                return (bytes / 1024 / 1024).toFixed(2);
            }

            function updateSelectedPdfMetaStorage() {
                const meta = selectedPDFs.map(p => ({
                    name: p.file?.name || '',
                    size: p.file?.size || 0,
                    addedAt: p.addedAt
                }));
                localStorage.setItem('ready2study_selected_pdfs', JSON.stringify(meta));

                // Keep legacy key for compatibility (shows count when multiple PDFs)
                const totalSize = meta.reduce((sum, m) => sum + (m.size || 0), 0);
                const displayName = meta.length === 1 ? meta[0].name : `${meta.length} PDFs`;
                localStorage.setItem('ready2study_pdf', JSON.stringify({
                    name: displayName,
                    size: totalSize,
                    uploaded: meta.length > 0,
                    uploadDate: new Date().toISOString()
                }));
            }

            function renderSelectedPDFs() {
                if (selectedPDFs.length === 0) {
                    fileInfo.style.display = 'none';
                    fileInfo.innerHTML = '';
                    generateBtn.disabled = true;
                    return;
                }

                const rowsHtml = selectedPDFs.map((p, idx) => {
                    const name = p.file?.name || 'PDF';
                    const size = p.file?.size || 0;
                    const addMoreBtn = idx === 0 ? `
                        <button onclick="addMorePDF()" style="background: var(--gradient-primary); color: white; border: none; padding: 0.5rem 0.85rem; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 700; transition: all 0.2s;">
                            Add More PDF
                        </button>
                    ` : '';
                    return `
                        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 1rem; background: #f0fdfa; border-radius: 0.5rem; border: 1px solid var(--border);">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color: var(--primary);">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                            <div style="flex: 1; min-width: 0;">
                                <strong style="color: var(--primary); display: block; margin-bottom: 0.25rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${name}</strong>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">${formatMB(size)} MB</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                ${addMoreBtn}
                                <button onclick="removePdfAt(${idx})" style="background: #fee2e2; color: #991b1b; border: none; padding: 0.5rem 0.85rem; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 700; transition: all 0.2s;" onmouseover="this.style.background='#fecaca'" onmouseout="this.style.background='#fee2e2'">
                                    Remove
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');

                fileInfo.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem;">
                        ${rowsHtml}
                    </div>
                `;

                fileInfo.style.display = 'block';
                generateBtn.disabled = false;
            }

            function startReadingArrayBuffer(entry) {
                entry.arrayBuffer = null;
                entry.arrayBufferPromise = new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        entry.arrayBuffer = e.target.result;
                        resolve(entry.arrayBuffer);
                    };
                    reader.onerror = function() {
                        reject(new Error('Error reading file: ' + (entry.file?.name || 'PDF')));
                    };
                    reader.readAsArrayBuffer(entry.file);
                });
            }

            function addPdfFile(file) {
                if (!isPdfFile(file)) return;

                const entry = {
                    file,
                    addedAt: new Date().toISOString(),
                    arrayBuffer: null,
                    arrayBufferPromise: null,
                };

                startReadingArrayBuffer(entry);
                selectedPDFs.push(entry);

                updateSelectedPdfMetaStorage();
                renderSelectedPDFs();
            }

            function addPdfFiles(files) {
                if (!files || files.length === 0) return;

                const list = Array.from(files);
                const pdfs = list.filter(isPdfFile);
                const nonPdfs = list.filter(f => !isPdfFile(f));

                if (nonPdfs.length > 0) {
                    alert('Only PDF files are allowed. Non-PDF files were ignored.');
                }
                if (pdfs.length === 0) return;

                pdfs.forEach(addPdfFile);
            }

            // Remove ONE PDF by index
            window.removePdfAt = function(index) {
                if (index < 0 || index >= selectedPDFs.length) return;
                selectedPDFs.splice(index, 1);
                updateSelectedPdfMetaStorage();
                renderSelectedPDFs();
            };

            // Add More PDF - opens file picker and ADDS to the list
            window.addMorePDF = function() {
                // Allow selecting the same file again by clearing the input value first
                fileInput.value = '';
                fileInput.click();
            };

            // Function to extract text from PDF - reads ALL pages completely
            async function extractTextFromPDF(arrayBuffer) {
                try {
                    // Set up PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // Load the PDF document
                    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                    const pdf = await loadingTask.promise;
                    
                    let fullText = '';
                    const totalPages = pdf.numPages;
                    
                    console.log(`ðŸ“„ Reading PDF with ${totalPages} pages...`);
                    console.log(`ðŸ“– Starting to read ALL pages completely...`);
                    
                    // Extract text from EACH AND EVERY page completely
                    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                        try {
                            const page = await pdf.getPage(pageNum);
                            const textContent = await page.getTextContent();
                            
                            // Better extraction that preserves mathematical formulas and equations
                            let pageText = '';
                            for (let item of textContent.items) {
                                // Preserve spacing and special characters for math
                                const text = item.str || '';
                                // Check if it's a mathematical expression (contains numbers, operators, etc.)
                                if (text.match(/[0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€]/) || text.trim().length > 0) {
                                    pageText += text + (item.hasEOL ? '\n' : ' ');
                                } else {
                                    pageText += text + ' ';
                                }
                            }
                            
                            // Add page separator
                            fullText += `\n--- Page ${pageNum} of ${totalPages} ---\n\n`;
                            fullText += pageText.trim();
                            fullText += '\n\n';
                            
                            console.log(`âœ… Page ${pageNum}/${totalPages} extracted successfully (${pageText.length} characters)`);
                        } catch (pageError) {
                            console.error(`âŒ Error reading page ${pageNum}:`, pageError);
                            // Continue with next page even if one fails
                            fullText += `\n--- Page ${pageNum} (Error reading) ---\n\n`;
                        }
                    }
                    
                    console.log(`âœ… PDF extraction complete!`);
                    console.log(`ðŸ“Š Total text length: ${fullText.length} characters`);
                    console.log(`ðŸ“„ Total pages read: ${totalPages}`);
                    return fullText.trim();
                } catch (error) {
                    console.error('Error extracting text from PDF:', error);
                    throw error;
                }
            }

            // Function to generate questions from PDF content - properly separates questions and answers
            function generateQuestionsFromPDF(pdfText) {
                console.log('Generating questions from PDF content...');
                console.log('PDF text length:', pdfText.length);
                console.log('First 500 chars of PDF:', pdfText.substring(0, 500));
                
                // Helper function to extract key concepts and topics from text
                function extractKeyConcepts(text) {
                    // Remove page markers and clean text
                    let cleanText = text.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                    
                    // Extract sentences
                    const sentences = cleanText.split(/[.!?]+/).filter(s => s.trim().length > 15);
                    
                    // Pronoun list for filtering (shared across functions)
                    const pronounList = ['this', 'these', 'that', 'those', 'then', 'there', 'their', 'they', 'them', 'it', 'its', 'he', 'she', 'him', 'her', 'his', 'hers', 'we', 'us', 'our', 'ours', 'you', 'your', 'yours', 'i', 'me', 'my', 'mine', 'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how'];
                    
                    // Extract important nouns and concepts (words that are capitalized or appear multiple times)
                    const words = cleanText.toLowerCase().split(/\s+/);
                    const wordFreq = {};
                    
                    words.forEach(w => {
                        const clean = w.replace(/[^a-z0-9]/g, '');
                        // Only count words that are at least 5 chars and not pronouns
                        if (clean.length >= 5 && !pronounList.includes(clean)) {
                            wordFreq[clean] = (wordFreq[clean] || 0) + 1;
                        }
                    });
                    
                    // Get most frequent meaningful words (exclude pronouns)
                    const importantWords = Object.entries(wordFreq)
                        .filter(([w, count]) => count > 0 && w.length >= 5 && !pronounList.includes(w))
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                        .map(([w]) => w);
                    
                    // Extract capitalized terms (likely concepts) - filter out pronouns
                    const capitalizedTerms = cleanText.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g) || [];
                    const uniqueCapTerms = [...new Set(capitalizedTerms)]
                        .filter(term => {
                            const lowerTerm = term.toLowerCase().replace(/[^a-z0-9]/g, '');
                            const words = term.split(/\s+/);
                            
                            // Filter out single-word pronouns and common words
                            if (words.length === 1) {
                                if (pronounList.includes(lowerTerm)) {
                                    return false;
                                }
                                // Single words must be at least 5 characters (to avoid "We", "It", etc.)
                                if (lowerTerm.length < 5) {
                                    return false;
                                }
                            }
                            
                            // Filter out if any word in the term is a pronoun
                            for (const word of words) {
                                const cleanWord = word.toLowerCase().replace(/[^a-z0-9]/g, '');
                                if (pronounList.includes(cleanWord)) {
                                    return false;
                                }
                            }
                            
                            // Minimum length check
                            return term.length >= 5;
                        })
                        .slice(0, 5);
                    
                    return {
                        sentences: sentences,
                        importantWords: importantWords,
                        capitalizedTerms: uniqueCapTerms,
                        fullText: cleanText
                    };
                }
                
                // Helper function to identify what a passage is about and create a question
                function createQuestionFromContent(passage, marks) {
                    if (!passage || passage.trim().length < 30) return null;
                    
                    const concepts = extractKeyConcepts(passage);
                    const sentences = concepts.sentences;
                    
                    if (sentences.length === 0) return null;
                    
                    // Clean the passage to use as answer
                    let answerText = passage.trim();
                    // Remove page markers from answer
                    answerText = answerText.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                    // Limit answer length based on marks
                    const maxAnswerLength = marks === 1 ? 200 : marks === 2 ? 300 : marks === 3 ? 500 : 1000;
                    answerText = answerText.substring(0, Math.min(maxAnswerLength, answerText.length)).trim();
                    
                    if (answerText.length < 30) return null;
                    
                    // Filter out generic/meaningless words, pronouns, and common words
                    const genericWords = ['this', 'these', 'that', 'those', 'then', 'there', 'their', 'they', 'them', 'the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall', 'it', 'its', 'he', 'she', 'him', 'her', 'his', 'hers', 'we', 'us', 'our', 'ours', 'you', 'your', 'yours', 'i', 'me', 'my', 'mine', 'what', 'which', 'who', 'whom', 'whose', 'where', 'when', 'why', 'how'];
                    
                    // Helper function to extract meaningful topic from text
                    function extractMeaningfulTopic(text) {
                        // Remove generic words and extract meaningful nouns/concepts
                        const words = text.toLowerCase().split(/\s+/)
                            .filter(w => {
                                const clean = w.replace(/[^a-z0-9]/g, '');
                                // Require longer words (at least 4 chars) to avoid pronouns
                                return clean.length >= 4 && !genericWords.includes(clean);
                            });
                        
                        // Look for meaningful phrases (2-4 words) - prefer multi-word topics
                        if (words.length >= 2) {
                            const phrase = words.slice(0, 3).map((w, i) => i === 0 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');
                            // Validate the phrase doesn't contain pronouns
                            if (isValidTopic(phrase)) {
                                return phrase;
                            }
                        } else if (words.length === 1) {
                            // Single word - must be validated
                            const word = words[0].charAt(0).toUpperCase() + words[0].slice(1);
                            if (isValidTopic(word) && word.length >= 5) {
                                return word;
                            }
                        }
                        return null;
                    }
                    
                    // Check if topic contains pronouns or generic words
                    function isValidTopic(topic) {
                        if (!topic || topic.length < 5) return false;
                        const lowerTopic = topic.toLowerCase();
                        const topicWords = lowerTopic.split(/\s+/);
                        
                        // Check if any word in the topic is a pronoun or generic word
                        for (const word of topicWords) {
                            const clean = word.replace(/[^a-z0-9]/g, '');
                            if (genericWords.includes(clean)) {
                                return false;
                            }
                        }
                        
                        // Check if topic is just a single pronoun or generic word
                        if (topicWords.length === 1) {
                            const singleWord = topicWords[0].replace(/[^a-z0-9]/g, '');
                            if (genericWords.includes(singleWord)) {
                                return false;
                            }
                            // Single words must be longer (at least 5 chars) to avoid pronouns
                            if (singleWord.length < 5) {
                                return false;
                            }
                        }
                        
                        // Additional check: if topic is a single short word, reject it
                        if (topicWords.length === 1 && topic.replace(/[^a-z0-9]/gi, '').length < 5) {
                            return false;
                        }
                        
                        return true;
                    }
                    
                    // Identify the main topic/concept from the passage
                    let mainTopic = '';
                    
                    // Try to find the main subject/topic - filter out pronouns immediately
                    if (concepts.capitalizedTerms.length > 0) {
                        // Use first capitalized term that is NOT a pronoun
                        for (const term of concepts.capitalizedTerms) {
                            if (isValidTopic(term)) {
                                mainTopic = term;
                                break;
                            }
                        }
                    }
                    
                    // If no valid capitalized term, try important words
                    if (!mainTopic && concepts.importantWords.length > 0) {
                        // Use important words, but filter out generic ones
                        const meaningfulWords = concepts.importantWords.filter(w => {
                            const clean = w.toLowerCase().replace(/[^a-z0-9]/g, '');
                            return !genericWords.includes(clean) && w.length > 4;
                        });
                        if (meaningfulWords.length > 0) {
                            mainTopic = meaningfulWords[0].charAt(0).toUpperCase() + meaningfulWords[0].slice(1);
                        }
                    }
                    
                    // If still no good topic, extract from sentences
                    if (!mainTopic || !isValidTopic(mainTopic)) {
                        for (let i = 0; i < Math.min(5, sentences.length); i++) {
                            const topic = extractMeaningfulTopic(sentences[i]);
                            if (topic && isValidTopic(topic)) {
                                mainTopic = topic;
                                break;
                            }
                        }
                    }
                    
                    // Final fallback - use first meaningful phrase from passage
                    if (!mainTopic || !isValidTopic(mainTopic)) {
                        const topic = extractMeaningfulTopic(passage);
                        if (topic && isValidTopic(topic)) {
                            mainTopic = topic;
                        } else {
                            // Last resort - use first sentence but skip generic words
                            const firstSentence = sentences[0] || passage;
                            const words = firstSentence.split(/\s+/)
                                .filter(w => {
                                    const clean = w.toLowerCase().replace(/[^a-z0-9]/g, '');
                                    return clean.length > 4 && !genericWords.includes(clean);
                                });
                            if (words.length > 0) {
                                const candidateTopic = words.slice(0, 3).map((w, i) => i === 0 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');
                                if (isValidTopic(candidateTopic)) {
                                    mainTopic = candidateTopic;
                                } else {
                                    // Try to find a better topic from important words
                                    if (concepts.importantWords.length > 0) {
                                        const meaningfulWords = concepts.importantWords
                                            .filter(w => !genericWords.includes(w.toLowerCase()) && w.length > 4)
                                            .slice(0, 2);
                                        if (meaningfulWords.length > 0) {
                                            mainTopic = meaningfulWords.map((w, i) => i === 0 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');
                                        } else {
                                            mainTopic = 'the concept';
                                        }
                                    } else {
                                        mainTopic = 'the concept';
                                    }
                                }
                            } else {
                                mainTopic = 'the concept';
                            }
                        }
                    }
                    
                    // Final validation - ensure mainTopic is valid before generating question
                    if (!mainTopic || !isValidTopic(mainTopic) || mainTopic === 'the concept') {
                        // Try one more time to extract a valid topic
                        for (let i = 0; i < Math.min(10, sentences.length); i++) {
                            const topic = extractMeaningfulTopic(sentences[i]);
                            if (topic && isValidTopic(topic)) {
                                mainTopic = topic;
                                break;
                            }
                        }
                        // If still no valid topic, skip this question
                        if (!mainTopic || !isValidTopic(mainTopic) || mainTopic === 'the concept') {
                            console.warn('Could not extract valid topic from passage, skipping question');
                            return null;
                        }
                    }
                    
                    // Check if it's mathematical content
                    const hasMath = /[0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€]/.test(passage);
                    
                    // Generate question based on marks
                    let questionText = '';
                    
                    if (hasMath) {
                        // Mathematical questions
                        const mathExpr = passage.match(/([0-9+\-*/=()^âˆšâˆ‘âˆ«Ï€\s]+)/)?.[0] || '';
                        if (marks === 1) {
                            questionText = `${mathExpr.substring(0, 80).trim()}`;
                        } else if (marks === 2) {
                            questionText = `${mathExpr.substring(0, 120).trim()}`;
                        } else {
                            questionText = `${mathExpr.substring(0, 150).trim()}`;
                        }
                    } else {
                        // Text-based questions - create proper exam questions
                        if (marks === 1) {
                            // Simple definition/recall
                            questionText = `What is ${mainTopic}?`;
                        } else if (marks === 2) {
                            // Short explanation
                            questionText = `Explain ${mainTopic}.`;
                        } else if (marks === 3) {
                            // Detailed explanation
                            questionText = `Describe ${mainTopic} in detail.`;
                        } else {
                            // Comprehensive (10 marks)
                            questionText = `Write a comprehensive answer about ${mainTopic}.`;
                        }
                    }
                    
                    // CRITICAL: Ensure question and answer are completely different
                    // Question should ask ABOUT something, answer should explain it
                    const normalizedQuestion = questionText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
                    const normalizedAnswer = answerText.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
                    
                    // Check if question and answer are too similar or topic is invalid
                    const topicLower = mainTopic.toLowerCase();
                    const hasInvalidWords = genericWords.some(word => topicLower.includes(word) && topicLower.split(/\s+/).some(w => w.replace(/[^a-z0-9]/g, '') === word));
                    
                    if (normalizedQuestion === normalizedAnswer || 
                        normalizedAnswer.includes(normalizedQuestion) && normalizedAnswer.length < normalizedQuestion.length * 2 ||
                        normalizedQuestion.length >= normalizedAnswer.length ||
                        hasInvalidWords || !isValidTopic(mainTopic)) {
                        // If too similar or topic is generic, try to extract a better topic from different sentences
                        let betterTopic = null;
                        for (let i = 1; i < Math.min(10, sentences.length); i++) {
                            const topic = extractMeaningfulTopic(sentences[i]);
                            if (topic && isValidTopic(topic)) {
                                betterTopic = topic;
                                break;
                            }
                        }
                        
                        // If still no good topic, use important words from the passage
                        if (!betterTopic && concepts.importantWords.length > 1) {
                            const meaningfulWords = concepts.importantWords
                                .filter(w => !genericWords.includes(w.toLowerCase()) && w.length > 4)
                                .slice(0, 2);
                            if (meaningfulWords.length > 0) {
                                betterTopic = meaningfulWords.map((w, i) => i === 0 ? w.charAt(0).toUpperCase() + w.slice(1) : w).join(' ');
                            }
                        }
                        
                        if (betterTopic) {
                            mainTopic = betterTopic;
                            if (marks === 1) {
                                questionText = `What is ${mainTopic}?`;
                            } else if (marks === 2) {
                                questionText = `Explain ${mainTopic}.`;
                            } else if (marks === 3) {
                                questionText = `Describe ${mainTopic} in detail.`;
                            } else {
                                questionText = `Write a comprehensive answer about ${mainTopic}.`;
                            }
                        }
                    }
                    
                    // Final validation
                    if (questionText.trim().length < 10 || answerText.trim().length < 30) {
                        return null;
                    }
                    
                    // Ensure answer is significantly longer than question
                    if (answerText.length <= questionText.length * 1.5) {
                        return null; // Answer too short, skip this
                    }
                    
                    return {
                        question: questionText.trim(),
                        answer: answerText.trim()
                    };
                }
                
                // Split text into meaningful sections (paragraphs, sections, etc.)
                // First, remove page markers
                let cleanText = pdfText.replace(/--- Page \d+ of \d+ ---/g, '').trim();
                
                // Split into paragraphs (double newlines or long single lines)
                let paragraphs = cleanText.split(/\n\s*\n/).filter(p => p.trim().length > 30);
                
                // If not enough paragraphs, try splitting by single newlines for longer sections
                if (paragraphs.length < 10) {
                    const lines = cleanText.split('\n').filter(l => l.trim().length > 50);
                    // Group consecutive lines into paragraphs
                    let currentPara = '';
                    lines.forEach(line => {
                        if (line.trim().length > 0) {
                            currentPara += line.trim() + ' ';
                            if (currentPara.length > 200) {
                                paragraphs.push(currentPara.trim());
                                currentPara = '';
                            }
                        } else if (currentPara.length > 30) {
                            paragraphs.push(currentPara.trim());
                            currentPara = '';
                        }
                    });
                    if (currentPara.length > 30) {
                        paragraphs.push(currentPara.trim());
                    }
                }
                
                // Remove duplicates and very short paragraphs
                paragraphs = [...new Set(paragraphs)].filter(p => p.trim().length > 30);
                
                console.log(`Found ${paragraphs.length} paragraphs/sections in PDF`);
                
                const questions = [];
                let questionId = 1;
                const examDate = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                
                // Generate MORE than 20 questions - ensure good distribution
                // Target: At least 20-25 questions total (minimum 20, aim for 25+)
                const targetCounts = {
                    1: Math.max(8, Math.min(12, Math.floor(paragraphs.length / 1.5) || 8)),  // Minimum 8, up to 12 questions
                    2: Math.max(8, Math.min(12, Math.floor(paragraphs.length / 1.5) || 8)),  // Minimum 8, up to 12 questions
                    3: Math.max(4, Math.min(8, Math.floor(paragraphs.length / 1.2) || 4)),   // Minimum 4, up to 8 questions
                    10: Math.max(2, Math.min(4, Math.floor(paragraphs.length / 1.0) || 2))   // Minimum 2, up to 4 questions
                };
                
                // Ensure minimum total of 20 questions
                const totalTarget = targetCounts[1] + targetCounts[2] + targetCounts[3] + targetCounts[10];
                if (totalTarget < 20) {
                    // Adjust to ensure at least 20 questions
                    const shortfall = 20 - totalTarget;
                    // Distribute shortfall across categories
                    targetCounts[1] += Math.ceil(shortfall * 0.4);
                    targetCounts[2] += Math.ceil(shortfall * 0.4);
                    targetCounts[3] += Math.ceil(shortfall * 0.15);
                    targetCounts[10] += Math.ceil(shortfall * 0.05);
                }
                
                console.log(`ðŸ“Š Target question counts: 1-mark=${targetCounts[1]}, 2-mark=${targetCounts[2]}, 3-mark=${targetCounts[3]}, 10-mark=${targetCounts[10]} (Total: ${targetCounts[1] + targetCounts[2] + targetCounts[3] + targetCounts[10]})`);
                
                // Track paragraph usage count (allow reuse for long paragraphs)
                const paragraphUsage = new Map();
                
                // Generate questions for each mark category
                [1, 2, 3, 10].forEach(marks => {
                    let generated = 0;
                    const targetCount = targetCounts[marks];
                    
                    console.log(`Generating ${targetCount} questions for ${marks}-mark category...`);
                    
                    // Try each paragraph until we have enough questions
                    // Allow reusing paragraphs if they're long enough - be more aggressive
                    for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                    const para = paragraphs[i].trim();
                        const minLength = marks === 1 ? 40 : marks === 2 ? 80 : marks === 3 ? 120 : 150; // Lowered minimums
                        
                        // Check usage - allow more reuse for longer paragraphs
                        const usageCount = paragraphUsage.get(i) || 0;
                        // More aggressive reuse: allow 3-4 uses for very long paragraphs
                        const maxReuse = para.length > 800 ? 4 : para.length > 500 ? 3 : para.length > 300 ? 2 : para.length > 150 ? 1 : 0;
                        
                        if (para.length >= minLength && usageCount < maxReuse) {
                            const qa = createQuestionFromContent(para, marks);
                            
                            if (qa && 
                                qa.question && 
                                qa.answer &&
                                qa.question.trim() !== qa.answer.trim() &&
                                qa.question.length > 8 && // Lowered minimum
                                qa.answer.length > qa.question.length * 1.2 && // Less strict ratio
                                !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                            
                            questions.push({
                                id: questionId++,
                                    question: qa.question,
                                    answer: qa.answer,
                                    marks: marks,
                                    examDate: examDate
                                });
                                
                                paragraphUsage.set(i, usageCount + 1);
                                generated++;
                                console.log(`âœ… Generated ${marks}-mark question ${generated}/${targetCount}: "${qa.question.substring(0, 50)}..."`);
                            }
                        }
                    }
                    
                    // If still not enough, try cycling through paragraphs multiple times
                    if (generated < targetCount) {
                        console.log(`âš ï¸ Only ${generated}/${targetCount} generated. Cycling through paragraphs again...`);
                        let attempts = 0;
                        const maxAttempts = paragraphs.length * 2; // Try twice through all paragraphs
                        
                        while (generated < targetCount && attempts < maxAttempts) {
                            for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                                const para = paragraphs[i].trim();
                                const minLength = marks === 1 ? 30 : marks === 2 ? 60 : marks === 3 ? 100 : 120; // Even lower
                                
                                const usageCount = paragraphUsage.get(i) || 0;
                                const maxReuse = para.length > 400 ? 5 : para.length > 200 ? 3 : 2; // More aggressive
                                
                                if (para.length >= minLength && usageCount < maxReuse) {
                                    const qa = createQuestionFromContent(para, marks);
                                    
                                    if (qa && 
                                        qa.question && 
                                        qa.answer &&
                                        qa.question.trim() !== qa.answer.trim() &&
                                        qa.question.length > 8 &&
                                        qa.answer.length > qa.question.length * 1.1 &&
                                        !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                                        
                        questions.push({
                            id: questionId++,
                                            question: qa.question,
                                            answer: qa.answer,
                                            marks: marks,
                                            examDate: examDate
                                        });
                                        
                                        paragraphUsage.set(i, usageCount + 1);
                                        generated++;
                                        attempts++;
                                    }
                                }
                                attempts++;
                            }
                        }
                    }
                    
                    // If still not enough, try splitting longer paragraphs into smaller chunks
                    if (generated < targetCount) {
                        console.log(`âš ï¸ Still need ${targetCount - generated} more ${marks}-mark questions. Splitting long paragraphs...`);
                        
                        // Try splitting longer paragraphs into smaller chunks
                        for (let i = 0; i < paragraphs.length && generated < targetCount; i++) {
                    const para = paragraphs[i].trim();
                            
                            // If paragraph is long enough, split it and generate multiple questions
                            if (para.length > 300) {
                                // Split by sentences
                                const sentences = para.split(/[.!?]+/).filter(s => s.trim().length > 30);
                                
                                // Create overlapping chunks to generate more questions
                                for (let startIdx = 0; startIdx < sentences.length - 1 && generated < targetCount; startIdx++) {
                                    // Take 2-4 sentences per chunk
                                    const chunkSize = marks === 1 ? 2 : marks === 2 ? 3 : marks === 3 ? 4 : 5;
                                    const chunk = sentences.slice(startIdx, startIdx + chunkSize).join('. ').trim();
                                    
                                    if (chunk.length >= (marks === 1 ? 40 : marks === 2 ? 80 : marks === 3 ? 120 : 150)) {
                                        const qa = createQuestionFromContent(chunk, marks);
                                        
                                        if (qa && 
                                            qa.question && 
                                            qa.answer &&
                                            qa.question.trim() !== qa.answer.trim() &&
                                            qa.question.length > 8 &&
                                            qa.answer.length > qa.question.length * 1.1 &&
                                            !questions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                            
                            questions.push({
                                id: questionId++,
                                                question: qa.question,
                                                answer: qa.answer,
                                                marks: marks,
                                                examDate: examDate
                                            });
                                            
                                            generated++;
                                            console.log(`âœ… Generated additional ${marks}-mark question from split: "${qa.question.substring(0, 50)}..."`);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    console.log(`ðŸ“Š Final count for ${marks}-mark: ${generated}/${targetCount} questions`);
                });
                
                // Final validation and cleanup - keep all valid questions (be less strict to keep more)
                const validQuestions = [];
                const seenQuestions = new Set();
                
                questions.forEach(q => {
                    const qNorm = q.question.toLowerCase().trim();
                    const aNorm = q.answer.toLowerCase().trim();
                    
                    // Less strict validation - ensure questions and answers are different but allow more through
                    if (q.question && 
                        q.answer &&
                        q.question.trim().length > 8 && // Lowered from 10
                        q.answer.trim().length > 25 && // Lowered from 30
                        qNorm !== aNorm &&
                        q.answer.length > q.question.length * 1.1 && // Less strict ratio (was 1.2)
                        !seenQuestions.has(qNorm)) {
                        
                        validQuestions.push(q);
                        seenQuestions.add(qNorm);
                    }
                });
                
                console.log(`ðŸ“‹ After validation: ${validQuestions.length} valid questions (from ${questions.length} generated)`);
                
                const countsByMark = {
                    1: validQuestions.filter(q => q.marks === 1).length,
                    2: validQuestions.filter(q => q.marks === 2).length,
                    3: validQuestions.filter(q => q.marks === 3).length,
                    10: validQuestions.filter(q => q.marks === 10).length
                };
                
                console.log(`âœ… Generated ${validQuestions.length} valid questions total:`);
                console.log(`   - ${countsByMark[1]} x 1-mark questions`);
                console.log(`   - ${countsByMark[2]} x 2-mark questions`);
                console.log(`   - ${countsByMark[3]} x 3-mark questions`);
                console.log(`   - ${countsByMark[10]} x 10-mark questions`);
                
                // If we have less than 20 questions, try to generate more from remaining content
                if (validQuestions.length < 20) {
                    console.log(`âš ï¸ Only ${validQuestions.length} questions generated. Target is 20+. Trying to generate more...`);
                    
                    // Try to generate more questions from unused or partially used paragraphs
                    const remainingParagraphs = paragraphs.filter((p, idx) => {
                        const usage = paragraphUsage.get(idx) || 0;
                        return usage === 0 || (p.length > 400 && usage < 2);
                    });
                    
                    // Generate additional questions from remaining content
                    [1, 2, 3, 10].forEach(marks => {
                        const currentCount = countsByMark[marks];
                        const targetCount = targetCounts[marks];
                        
                        if (currentCount < targetCount) {
                            const needed = targetCount - currentCount;
                            let generated = 0;
                            
                            for (let para of remainingParagraphs) {
                                if (generated >= needed) break;
                                
                                const qa = createQuestionFromContent(para, marks);
                                if (qa && 
                                    qa.question && 
                                    qa.answer &&
                                    qa.question.trim() !== qa.answer.trim() &&
                                    !validQuestions.some(q => q.question.toLowerCase() === qa.question.toLowerCase())) {
                                    
                                    validQuestions.push({
                                id: questionId++,
                                        question: qa.question,
                                        answer: qa.answer,
                                        marks: marks,
                                        examDate: examDate
                                    });
                                    generated++;
                                }
                            }
                        }
                    });
                    
                    console.log(`âœ… After additional generation: ${validQuestions.length} total questions`);
                }
                
                // Final check - if still not enough, add from mock data (but only as last resort)
                if (validQuestions.length < 4) {
                    console.warn('âš ï¸ Not enough questions generated, adding mock questions as fallback');
                    const mockQuestionsToAdd = mockQuestions.slice(0, Math.min(4 - validQuestions.length, 4));
                    mockQuestionsToAdd.forEach(q => {
                        if (q.question && q.answer && q.question !== q.answer) {
                            validQuestions.push({
                            ...q,
                                id: questionId++,
                                examDate: examDate
                            });
                        }
                    });
                }
                
                // Sort questions by marks for better organization
                validQuestions.sort((a, b) => {
                    if (a.marks !== b.marks) return a.marks - b.marks;
                    return a.id - b.id;
                });
                
                console.log(`ðŸŽ‰ Final result: ${validQuestions.length} questions ready for use!`);
                
                return validQuestions;
            }

            // Generate questions button handler
            generateBtn.addEventListener('click', async () => {
                const selectedPDFs = Array.isArray(window.selectedPDFs) ? window.selectedPDFs : [];
                if (selectedPDFs.length === 0) {
                    alert('Please upload at least one PDF file first.');
                    return;
                }

                // Disable button during processing
                generateBtn.disabled = true;
                generateBtn.textContent = 'Processing...';
                loader.style.display = 'flex';
                
                const loaderTitle = document.getElementById('loaderTitle');
                const loaderMessage = document.getElementById('loaderMessage');
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                
                // Multi-PDF processing state
                const allQuestionsCombined = [];
                const pdfSummaries = [];
                let globalQuestionId = 1;
                let combinedPdfText = '';
                let backendAvailable = true;

                try {
                    const total = selectedPDFs.length;

                    for (let i = 0; i < total; i++) {
                        const entry = selectedPDFs[i];
                        const file = entry?.file;
                        if (!file) continue;

                        // Ensure ArrayBuffer is ready
                        loaderTitle.textContent = `Reading PDF ${i + 1}/${total}...`;
                        loaderMessage.textContent = `Extracting ALL pages: ${file.name}`;
                        progressBar.style.width = `${Math.round(((i) / total) * 100)}%`;
                        progressText.textContent = `${i + 1}/${total} - Reading ${file.name}...`;

                        const arrayBuffer = entry.arrayBuffer || (entry.arrayBufferPromise ? await entry.arrayBufferPromise : null);
                        if (!arrayBuffer) {
                            throw new Error(`PDF file is still loading: ${file.name}`);
                        }

                        // Extract text
                        const pdfText = await extractTextFromPDF(arrayBuffer);
                        combinedPdfText += `\n\n===== ${file.name} =====\n\n${pdfText}\n`;

                        // Generate questions
                        loaderTitle.textContent = `Generating Questions ${i + 1}/${total}...`;
                        loaderMessage.textContent = `Creating questions from: ${file.name}`;
                        progressBar.style.width = `${Math.round(((i + 0.5) / total) * 100)}%`;
                        progressText.textContent = `${i + 1}/${total} - Generating questions...`;

                        const pdfQuestions = generateQuestionsFromPDF(pdfText) || [];

                        // Add to combined list with globally unique IDs + PDF name label
                        pdfQuestions.forEach(q => {
                            allQuestionsCombined.push({
                                id: globalQuestionId++,
                                question: q.question,
                                answer: q.answer,
                                marks: q.marks,
                                examDate: q.examDate || null,
                                pdfName: file.name
                            });
                        });

                        let savedPdfId = null;

                        // Upload + save to backend (optional; auto-falls back to offline if DB is down)
                        if (backendAvailable) {
                            try {
                                loaderTitle.textContent = `Uploading ${i + 1}/${total}...`;
                                loaderMessage.textContent = `Saving to database: ${file.name}`;
                                progressBar.style.width = `${Math.round(((i + 0.8) / total) * 100)}%`;
                                progressText.textContent = `${i + 1}/${total} - Uploading to server...`;

                                const pdfResponse = await PDFAPI.upload(file, pdfText);
                                savedPdfId = pdfResponse?.pdf?.id ?? null;

                                if (savedPdfId) {
                                    const questionsForAPI = pdfQuestions.map(q => ({
                                        question_text: q.question,
                                        answer_text: q.answer,
                                        marks: q.marks,
                                        exam_date: q.examDate || null,
                                    }));
                                    await QuestionAPI.createBulk(savedPdfId, questionsForAPI);
                                }
                            } catch (err) {
                                const msg = (err && err.message) ? err.message : String(err);
                                const looksLikeDbIssue = /database unavailable|cannot reach mysql|mysql|database connection|timed out/i.test(msg);
                                if (looksLikeDbIssue) {
                                    backendAvailable = false;
                                    console.warn('âš ï¸ Backend unavailable. Continuing in OFFLINE mode for remaining PDFs.');
                                } else {
                                    throw err;
                                }
                            }
                        }

                        pdfSummaries.push({
                            id: savedPdfId,
                            name: file.name,
                            size: file.size,
                            questionCount: pdfQuestions.length
                        });
                    }

                    // Finalizing
                    loaderTitle.textContent = 'Finalizing...';
                    loaderMessage.textContent = 'Preparing questions and answers for display';
                    progressBar.style.width = '100%';
                    progressText.textContent = `100% - Complete! (${allQuestionsCombined.length} questions)`;

                    await new Promise(resolve => setTimeout(resolve, 400));

                    // Store combined questions + a summary of PDFs
                    localStorage.setItem('ready2study_pdf_questions', JSON.stringify(allQuestionsCombined));
                    localStorage.setItem('ready2study_multi_pdfs', JSON.stringify(pdfSummaries));
                    localStorage.setItem('ready2study_pdf_uploaded', 'true');

                    // Store a combined (truncated) PDF content for "View Full PDF Content" section
                    const MAX_LOCAL_CONTENT = 500000; // keep under typical localStorage limits
                    const safeCombinedText = combinedPdfText.length > MAX_LOCAL_CONTENT
                        ? combinedPdfText.slice(0, MAX_LOCAL_CONTENT)
                        : combinedPdfText;
                    localStorage.setItem('ready2study_pdf_content', safeCombinedText);

                    const displayName = selectedPDFs.length === 1 ? selectedPDFs[0].file.name : `${selectedPDFs.length} PDFs`;
                    localStorage.setItem('ready2study_pdf_name', displayName);

                    // For multi-PDF mode, avoid forcing the dashboard to fetch a single PDF from API
                    if (pdfSummaries.length === 1 && pdfSummaries[0].id) {
                        localStorage.setItem('ready2study_current_pdf_id', String(pdfSummaries[0].id));
                    } else {
                        localStorage.removeItem('ready2study_current_pdf_id');
                    }

                    loader.style.display = 'none';
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Questions';

                    // Small delay to ensure localStorage is saved before redirect
                    await new Promise(resolve => setTimeout(resolve, 100));
                    window.location.href = 'dashboard.html';
                    
                } catch (error) {
                    console.error('Error processing PDFs:', error);
                    loader.style.display = 'none';
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Questions';
                    const msg = (error && error.message) ? error.message : String(error);
                    alert('Error processing PDFs. Please try again. Error: ' + msg);
                }
            });

            // Prevent default drag behaviors on the page
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
        });
    </script>
</body>
</html>